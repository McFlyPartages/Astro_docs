---
title: Mise à jour vers Astro v5
description: Comment mettre à jour votre projet vers Astro v5.0.
sidebar:
  label: v5.0
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import { Steps } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro'
import SourcePR from '~/components/SourcePR.astro'

Ce guide vous aidera à migrer d'Astro v4 à Astro v5.

Vous devez d'abord mettre à jour un ancien projet vers la version 4 ? Consultez notre [ancien guide de migration](/fr/guides/upgrade-to/v4/).

Besoin de voir la documentation de la v4 ? Visitez cette [ancienne version du site de documentation (snapshot v4.16 non maintenu)](https://v4.docs.astro.build/).

## Mettre à jour Astro

Mettez à jour la version d'Astro de votre projet vers la dernière version en utilisant votre gestionnaire de paquets :

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # Mettre à jour Astro et les intégrations officielles ensemble
  npx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # Mettre à jour Astro et les intégrations officielles ensemble
  pnpm dlx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # Mettre à jour Astro et les intégrations officielles ensemble
  yarn dlx @astrojs/upgrade
  ```
  </Fragment>
</PackageManagerTabs>

Vous pouvez également [mettre à jour manuellement vos intégrations Astro](/fr/guides/integrations-guide/#manual-upgrading) si nécessaire, et vous devrez peut-être aussi mettre à jour d'autres dépendances de votre projet.

:::note[Besoin de continuer ?]
Après avoir mis à jour Astro, il est possible que vous n'ayez pas besoin d'apporter de modifications à votre projet !

Cependant, si vous remarquez des erreurs ou un comportement inattendu, veuillez vérifier ci-dessous ce qui a changé et qui pourrait nécessiter une mise à jour dans votre projet.
:::

Astro v5.0 inclut des [changements potentiellement cassants](#breaking-changes), ainsi que la suppression et la dépréciation de certaines fonctionnalités.

Si votre projet ne fonctionne pas comme prévu après la mise à jour vers la version 5.0, consultez ce guide pour un aperçu de tous les changements cassants et des instructions sur la façon de mettre à jour votre base de code.

Consultez le changelog d'Astro](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) pour les notes de version complètes.

## Mises à jour des dépendances

Toute mise à jour majeure des dépendances d'Astro peut entraîner des changements cassants dans votre projet.

### Vite 6.0

Astro v5.0 passe à Vite v6.0 comme serveur de développement et bundler de production.

#### Que dois-je faire ?

Si vous utilisez des plugins, une configuration ou des API spécifiques à Vite, consultez le [guide de migration de Vite](https://vite.dev/guide/migration.html) pour connaître leurs changements cassants et mettez à jour votre projet si nécessaire.

### `@astrojs/mdx`

<SourcePR number="11741" title="Nettoyage du code JSX inutilisé"/>

Dans Astro v4.x, Astro effectuait un traitement interne du JSX pour l'intégration @astrojs/mdx.

Astro v5.0 transfère cette responsabilité de gestion et de rendu du JSX et MDX directement au package @astrojs/mdx. Cela signifie qu'Astro 5.0 n'est plus compatible avec les anciennes versions de l'intégration MDX.

#### Que dois-je faire ?

Si votre projet inclut des fichiers .mdx, vous devez mettre à jour @astrojs/mdx vers la dernière version (v4.0.0) afin que votre JSX soit correctement géré par l'intégration.

Si vous utilisez un rendu serveur MDX avec l'[API Container expérimentale d'Astro](/fr/reference/container-reference/), vous devez mettre à jour l'importation pour refléter le nouvel emplacement :

```ts del={1} ins={2}
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

<ReadMore>En savoir plus sur l'[utilisation de MDX dans votre projet](/fr/guides/integrations-guide/mdx/).</ReadMore>

## Héritage

Les fonctionnalités suivantes sont désormais considérées comme des fonctionnalités héritées. Elles devraient fonctionner normalement mais ne sont plus recommandées et sont en mode maintenance. Elles ne bénéficieront d'aucune amélioration future et la documentation ne sera pas mise à jour. Ces fonctionnalités seront éventuellement dépréciées, puis complètement supprimées..

### Héritage : API des Collections de Contenu v2.0

Dans Astro 4.x, les collections de contenu étaient définies, interrogées et rendues en utilisant l'[API des Collections de Contenu introduite pour la première fois dans Astro v2.0](https://astro.build/blog/introducing-content-collections/).

Astro 5.0 introduit une nouvelle version des collections de contenu utilisant l'API Content Layer qui apporte plusieurs améliorations de performance et des capacités supplémentaires. Bien que les anciennes collections (héritées) et les nouvelles (API Content Layer) puissent continuer à coexister dans cette version, il y a potentiellement des changements incompatibles pour les collections héritées existantes.

#### Que dois-je faire

Nous recommandons de [convertir toutes les collections existantes](#mise-a-jour-des-collections-existantes) vers la nouvelle API Content Layer dès que possible et de créer toute nouvelle collection en utilisant l'API Content Layer.

Si vous ne pouvez pas convertir vos collections, veuillez consulter [les changements incompatibles pour les collections héritées](#rupture-des-anciennes-collections-content-et-data) pour voir si vos collections existantes sont affectées et nécessitent une mise à jour.

Si vous ne pouvez apporter aucune modification à vos collections pour le moment, vous pouvez activer l'option `legacy.collections`](#activation-de-l-option-legacy.collections) qui vous permettra de conserver vos collections dans leur état actuel jusqu'à ce que le drapeau hérité ne soit plus pris en charge.

<ReadMore>En savoir plus sur la [mise à jour des collections de contenu](/fr/guides/content-collections/).</ReadMore>

##### Mise à jour des collections existantes

Voir les instructions ci-dessous pour mettre à jour une collection de contenu existante (`type : 'content' ou `type : 'data') afin d'utiliser l'API de la couche de contenu.

<details>
<summary>Instructions étape par étape pour mettre à jour une collection</summary>

<Steps>

1. **Déplacer le fichier de configuration du contenu**. Ce fichier ne se trouve plus dans le dossier `src/content/`. Ce fichier devrait maintenant exister dans `src/content.config.ts`.

2. **Éditez la définition de la collection**. Votre collection mise à jour nécessite un `loader`, et l'option pour sélectionner un `type` de collection n'est plus disponible.

    ```ts ins={3,8} del={7}
    // src/content.config.ts
    import { defineCollection, z } from 'astro:content';
    import { glob } from 'astro/loaders';

    const blog = defineCollection({
      // Pour les couches de contenu, vous ne définissez plus de `type`.
      type: 'content',
      loader: glob({ pattern: '**/[^_]*.md', base: "./src/data/blog" }),
      schema: z.object({
        title: z.string(),
        description: z.string(),
        pubDate: z.coerce.date(),
        updatedDate: z.coerce.date().optional(),
      }),
    });
    ```

3. **Changer les références de `slug` à `id`**. Les collections de couches de contenu n'ont pas de champ `slug` réservé. À la place, toutes les collections mises à jour auront un `id`. Vous pouvez également avoir besoin de mettre à jour les noms des fichiers de routage dynamique pour correspondre à un paramètre getStaticPaths() modifié :

    ```astro ins={7} del={6}
    // src/pages/[id].astro
    ---
    export async function getStaticPaths() {
      const posts = await getCollection('blog');
      return posts.map((post) => ({
        params: { slug: post.slug },
        params: { id: post.id },
        props: post,
      }));
    }
    ---
    ```

4. **Basculez vers la nouvelle fonction `render()`**. Les entrées n'ont plus de méthode `render()`, car elles sont maintenant des objets simples sérialisables. À la place, importez la fonction `render()` de `astro:content`.

    ```astro title="src/pages/index.astro" ins=", render" del={6} ins={7}
    ---
    import { getEntry, render } from 'astro:content';

    const post = await getEntry('blog', params.slug);

    const { Content, headings } = await post.render();
    const { Content, headings } = await render(post);
    ---
    <Content />
    ```
</Steps>

</details>

##### Rupture des anciennes collections `content` et `data`.

<SourcePR number="11976" title="Mise en œuvre des collections existantes à l'aide de glob" />

Par défaut, les collections qui utilisent l'ancienne propriété `type` (`content` ou `data`) et qui ne définissent pas de `loader` sont maintenant implémentées sous le capot en utilisant le chargeur intégré `glob()` de l'API de la couche de contenu, avec une gestion supplémentaire de la rétrocompatibilité.

De plus, une rétrocompatibilité temporaire existe pour conserver le fichier de configuration du contenu dans son emplacement original de `src/content/config.ts`.

Cette implémentation de la rétrocompatibilité est capable d'émuler la plupart des fonctionnalités des anciennes collections et permettra à de nombreuses anciennes collections de continuer à fonctionner même sans mettre à jour votre code. Cependant, **il y a des différences et des limitations qui peuvent entraîner des changements radicaux dans les collections existantes** :

  - Dans les versions précédentes d'Astro, les collections étaient générées pour tous les dossiers dans `src/content/`, même s'ils n'étaient pas définis dans `src/content/config.ts`. Ce comportement est maintenant déprécié, et les collections doivent toujours être définies dans `src/content.config.ts`. Pour les collections existantes, il peut s'agir de déclarations vides (par exemple `const blog = defineCollection({})`) et Astro définira implicitement votre ancienne collection pour vous d'une manière compatible avec le nouveau comportement de chargement.
  - Le champ spécial `layout` n'est pas supporté dans les entrées de collection Markdown. Cette propriété n'est destinée qu'aux fichiers de pages autonomes situés dans `src/pages/` et n'est pas susceptible de se trouver dans les entrées de votre collection. Cependant, si vous utilisiez cette propriété, vous devez maintenant créer des routes dynamiques qui incluent le style de votre page.
  - L'ordre de tri des collections générées n'est pas déterministe et dépend de la plate-forme. Cela signifie que si vous appelez `getCollection()`, l'ordre dans lequel les entrées sont retournées peut être différent de ce qu'il était auparavant. Si vous avez besoin d'un ordre spécifique, vous devez trier les entrées de la collection vous-même.
  - `image().refine()` n'est pas supporté. Si vous avez besoin de valider les propriétés d'une image, vous devrez le faire au moment de l'exécution de votre page ou de votre composant.
  - L'argument `key` de `getEntry(collection, key)` est typé comme `string`, plutôt que d'avoir des types pour chaque entrée.
  - Auparavant, quand on appelait `getEntry(collection, key)` avec une chaîne statique comme clé, le type de retour n'était pas nullable.  Le type inclut maintenant `undefined`, vous devez donc vérifier si l'entrée est définie avant d'utiliser le résultat ou vous aurez des erreurs de type.

##### Activation de l'option `legacy.collections`.

<SourcePR number="11976" title="Mise en œuvre des collections héritées à l'aide de glob" />

Si vous n'êtes pas encore prêt à mettre à jour vos collections existantes, vous pouvez activer l'indicateur [`legacy.collections`](/fr/reference/legacy-flags/) et vos collections existantes continueront à fonctionner comme avant.

## Déprécié

Les fonctionnalités dépréciées suivantes ne sont plus supportées et ne sont plus documentées. Veuillez mettre à jour votre projet en conséquence.

Certaines fonctionnalités obsolètes peuvent continuer à fonctionner temporairement jusqu'à ce qu'elles soient complètement supprimées. D'autres peuvent n'avoir aucun effet ou générer une erreur vous invitant à mettre à jour votre code.

### Déprécié: `Astro.glob()`

<SourcePR number="11826" title="Déprécier glob"/>

Dans Astro v4.x, vous pouviez utiliser `Astro.glob()` dans vos composants `.astro` pour interroger plusieurs fichiers dans votre projet. Cela avait quelques limitations (où cela pouvait être utilisé, performances, etc.), et l'utilisation des fonctions de requête de l'API Content Collections ou de `import.meta.glob()` propre à Vite fournissait souvent plus de fonctions et de flexibilité.

Astro 5.0 déprécie `Astro.glob()` en faveur de l'utilisation de `getCollection()` pour interroger vos collections, et de `import.meta.glob()` pour interroger d'autres fichiers sources dans votre projet.

#### Que dois-je faire ?

Remplacez toutes les utilisations de `Astro.glob()` par `import.meta.glob()`. Notez que `import.meta.glob()` ne retourne plus de `Promise`, vous devrez donc mettre à jour votre code en conséquence. Vous ne devriez pas avoir besoin de mettre à jour vos [motifs globaux](/fr/guides/imports/#glob-patterns).

```astro title="src/pages/blog.astro" del={2} ins={3}
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---

{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

Le cas échéant, envisagez d'utiliser [content collections](/fr/guides/content-collections/) pour organiser votre contenu, qui dispose de ses propres fonctions d'interrogation, plus récentes et plus performantes.

Vous pouvez également envisager d'utiliser les paquets globaux de NPM, tels que [`fast-glob`](https://www.npmjs.com/package/fast-glob).

<ReadMore>En savoir plus sur [l'importation de fichiers avec `import.meta.glob`](/fr/guides/imports/#importmetaglob).</ReadMore>
 
### Déprécié : `functionPerRoute` (API Adaptateur)

<SourcePR number="11714" title="Supprimer l'option functionPerRoute"/>

Dans Astro v4.x, vous pouviez opter pour la création d'un fichier séparé pour chaque route définie dans le projet, reflétant votre répertoire `src/pages/` dans le dossier de construction. Par défaut, Astro émettait un seul fichier `entry.mjs`, qui était responsable de l'émission de la page rendue à chaque requête.

Astro v5.0 supprime l'option permettant d'abandonner le comportement par défaut. Ce comportement est maintenant standard et non configurable.

Supprimez la propriété `functionPerRoute` de votre configuration `adapterFeatures`. Elle n'est plus disponible.

```js title="my-adapter.mjs" del={10}
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}

```

<ReadMore>En savoir plus sur [l'API d'adaptateur](/fr/reference/adapter-reference/) pour construire des intégrations d'adaptateur.</ReadMore>

### Déprécié: `routes` sur le hook `astro:build:done`(API d'intégration)

<SourcePR number="12329" title="feat(next): astro:routes:resolved"/>

Dans Astro v4.x, les intégrations accédaient aux routes à partir du hook `astro:build:done`.

Astro v5.0 déprécie le tableau `routes` passé à ce crochet. À la place, il expose un nouveau hook `astro:routes:resolved` qui s'exécute avant `astro:config:done`, et à chaque fois qu'une route change dans le développement. Il a toutes les mêmes propriétés que la liste `routes` obsolète, sauf `distURL` qui n'est disponible que pendant la construction.  

#### Que dois-je faire ?

Supprimez toute instance de `routes` passée à `astro:build:done` et remplacez-la par le nouveau hook `astro:routes:resolved`. Accédez à `distURL` sur la carte `assets` nouvellement exposée :

```js title="mon-integration.mjs" ins={2,6-8,11,13-18} del={10}
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

<ReadMore>En savoir plus sur [le hook `astro:routes:resolved` de l'API d'intégration](/en/reference/integrations-reference/#astroroutesresolved) pour créer des intégrations.</ReadMore>

## Supprimées

Les fonctionnalités suivantes ont été entièrement supprimées de la base de code et ne peuvent plus être utilisées. Certaines de ces fonctionnalités peuvent avoir continué à fonctionner dans votre projet même après la suppression. D'autres peuvent n'avoir eu aucun effet.

Les projets contenant ces fonctionnalités supprimées seront incapables de se construire, et il n'y aura plus de documentation vous invitant à supprimer ces fonctionnalités.

### Supprimée : L'intégration Lit

<SourcePR number="11680" title="Supprimée `@astrojs/lit`"/>

Dans Astro v4.x, [Lit](https://lit.dev/) était une bibliothèque de base maintenue par le paquet `@astrojs/lit`.

Astro v5.0 supprime cette intégration et ne recevra plus de mises à jour pour assurer la compatibilité avec les versions 5.x et supérieures.


#### Que dois-je faire ?

Vous pouvez continuer à utiliser Lit pour les composants client en ajoutant une balise de script côté client. Par exemple :

```astro
<script>
  import "../components/MyTabs";
</script>

<my-tabs title="Ceci est mon tableau">...</my-tabs>
```

Si vous souhaitez maintenir vous-même une intégration Lit, vous pouvez utiliser la [dernière version publiée de `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) comme point de départ et mettre à jour les paquets appropriés.

<ReadMore>En savoir plus sur les [intégrations officielles d'Astro](/fr/guides/integrations-guide/).</ReadMore>

### Supprimé : Mode de rendu `hybride`.

<SourcePR number="11824" title="Fusionner output:hybrid et output:static" />

Dans Astro v4.x, Astro fournissait trois modes de rendu `output` : `'static'`, `'hybrid'`, et `'server'`.

Astro v5.0 fusionne les modes de rendu `output : 'hybrid'` et `output : 'static'` en une seule configuration (maintenant appelée `'static'`) qui fonctionne de la même manière que l'option hybride précédente.

Il n'est plus nécessaire de spécifier `output : 'hybrid'` dans votre configuration Astro pour utiliser les pages rendues par le serveur. La nouvelle option `output : 'static'` a cette capacité incluse.

Astro vous permettra désormais de désactiver automatiquement le pré-rendu dans votre site statique sans qu'aucune modification de votre configuration de sortie ne soit nécessaire. N'importe quelle route ou point d'arrivée de page peut inclure `export const prerender = false` pour être rendu par le serveur à la demande, alors que le reste de votre site est généré statiquement.

#### Que dois-je faire ?

Si votre projet utilisait le rendu hybride, vous devez maintenant supprimer l'option `output : 'hybrid'` de votre configuration Astro, car elle n'existe plus. Cependant, aucune autre modification de votre projet n'est nécessaire, et vous ne devriez pas avoir de rupture. Le comportement précédent `'hybrid'` est maintenant le comportement par défaut, sous un nouveau nom `'static'`.

```js title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  output: 'hybrid',
});
```

Si vous utilisiez l'option `output : 'static'` (par défaut), vous pouvez continuer à l'utiliser comme avant. Par défaut, toutes vos pages continueront à être pré-rendues et vous aurez un site complètement statique. Vous ne devriez pas avoir de changement majeur dans votre projet.

Un adaptateur est toujours nécessaire pour déployer un projet Astro avec des pages rendues par le serveur, quel que soit le mode de sortie `output mode` utilisé par votre projet. Si vous n'incluez pas d'adaptateur, vous recevrez un avertissement pendant le développement et une erreur au moment de la compilation..

<ReadMore>En savoir plus sur [le rendu à la demande dans Astro](/fr/guides/on-demand-rendering/).</ReadMore>

### Supprimé : Service d'images Squoosh

<SourcePR number="11770" title="supprimer le service d'image squoosh"/>

Dans Astro 4.x, vous pouviez configurer `image.service : squooshImageService()` pour utiliser Squoosh pour transformer vos images à la place de Sharp. Cependant, la bibliothèque sous-jacente `libsquoosh` n'est plus maintenue et présente des problèmes de mémoire et de performance.

Astro 5.0 supprime entièrement le service d'optimisation d'images Squoosh.

#### Que dois-je faire ?

Pour passer au service d'image Sharp intégré, supprimez l'import `squooshImageService` de votre configuration Astro. Par défaut, vous utiliserez Sharp pour `astro:assets`.

```ts title="astro.config.mjs" del={1, 5-7}
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";

export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

Si vous utilisez un gestionnaire de paquets strict comme `pnpm`, vous pouvez avoir besoin d'installer le paquet `sharp` manuellement pour utiliser le service d'image Sharp, même s'il est intégré à Astro par défaut.

Si votre adaptateur ne supporte pas l'optimisation d'image Sharp intégrée à Astro, vous pouvez [configurer un service d'image no-op](/fr/guides/images/#configure-no-op-passthrough-service) pour vous permettre d'utiliser les composants `<Image />` et `<Picture />`.

Vous pouvez également envisager [un service d'images Squoosh maintenu par la communauté](https://github.com/Princesseuh/astro-image-service-squoosh) si vous ne pouvez pas utiliser le service d'images Sharp.

##### Pour les adaptateurs

Si votre adaptateur précisait auparavant son statut de compatibilité avec Squoosh, vous devez maintenant supprimer cette information de la configuration de votre adaptateur.

```js title="my-adapter.mjs" del={2-4}
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

<ReadMore>En savoir plus sur [la configuration de votre service d'images par défaut](/fr/guides/images/#default-image-service).</ReadMore>

### Supprimé : certains types orientés vers le public

<SourcePR number="11715" title="Refactor/types"/>

Dans Astro v4.x, `@types/astro.ts` exposait publiquement tous les types aux utilisateurs, qu'ils soient encore activement utilisés ou seulement destinés à un usage interne.

Astro v5.0 refactorise ce fichier pour supprimer les types obsolètes et internes. Ce remaniement apporte des améliorations à votre éditeur (par exemple, des complétions plus rapides, une utilisation plus faible de la mémoire et des options de complétion plus pertinentes). Cependant, ce remaniement peut provoquer des erreurs dans certains projets qui s'appuient sur des types qui ne sont plus disponibles pour le public.

#### Que dois-je faire ?

Supprimez tous les types qui provoquent des erreurs dans votre projet car vous n'y avez plus accès. Il s'agit principalement d'API qui ont été précédemment dépréciées et supprimées, mais il peut également s'agir de types qui sont désormais internes.

<ReadMore>Voir les [types publics exposés à l'utilisation](https://github.com/withastro/astro/tree/main/packages/astro/src/types/public).</ReadMore>

### Options expérimentales

Les options expérimentales suivantes ont été supprimées dans la version 5.0 d'Astro et peuvent désormais être utilisées :

- `env`
- `serverIslands`


Additionally, the following experimental flags have been removed and **are now the default or recommended behavior in Astro v5.0**.

- `directRenderScript` (See below for breaking changes to [default `<script>` behavior](#script-tags-are-rendered-directly-as-declared).)
- `globalRoutePriority` (See below for breaking changes to [default route priority order](#route-priority-order-for-injected-routes-and-redirects).)
- `contentLayer` (See guidance for [upgrading existing content collections](#legacy-v20-content-collections-api) to the new, preferred Content Layer API.)

The following experimental flags have been removed and **their corresponding features are not part of Astro v5.0**.

- `contentCollectionsCache`

Remove these experimental flags if you were previously using them, and move your `env` configuration to the root of your Astro config:

```js del={5-12} ins={14-16} title="astro.config.mjs"
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

These features are all available by default in Astro v5.0.

<ReadMore>Read about these exciting features and more in [the v5.0 Blog post](https://astro.build/blog/astro-5/).</ReadMore>

## Changed Defaults

Some default behavior has changed in Astro v5.0 and your project code may need updating to account for these changes.

In most cases, the only action needed is to review your existing project's deployment and ensure that it continues to function as you expect, making updates to your code as necessary. In some cases, there may be a configuration setting to allow you to continue to use the previous default behavior.

### CSRF protection is now set by default

<SourcePR number="11788" title="change default value of checkOrigin"/>

In Astro v4.x, The default value of `security.checkOrigin` was `false`. Previously, you had to explicitly set this value to `true` to enable Cross-Site Request Forgery (CSRF) protection.

Astro v5.0 changes the default value of this option to `true`, and will automatically check that the "origin" header matches the URL sent by each request in on-demand rendered pages.

#### Que dois-je faire ?

If you had previously configured `security.checkOrigin: true`, you no longer need this line in your Astro config. This is now the default.

To disable this behavior, you must explicitly set  `security.checkOrigin: false`.

```js title="astro.config.mjs" ins={3-5}
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

<ReadMore>Read more about [security configuration options](/en/reference/configuration-reference/#security)</ReadMore>

### Route priority order for injected routes and redirects

<SourcePR number="11798" title="Remove legacy route prioritization"/>

In Astro v4.x, `experimental.globalRoutePriority` was an optional flag that ensured that injected routes, file-based routes, and redirects were all prioritized using the [route priority order rules for all routes](/en/guides/routing/#route-priority-order). This allowed more control over routing in your project by not automatically prioritizing certain kinds of routes and standardizing the route priority order.

Astro v5.0 removes this experimental flag and makes this the new default behavior in Astro: redirects and injected routes are now prioritized equally alongside file-based project routes.

Note that this was already the default behavior in Starlight, and should not affect updated Starlight projects.

#### Que dois-je faire ?

If your project includes injected routes or redirects, please check that your routes are building page URLs as expected. An example of the new expected behavior is shown below.

In a project containing the following routes:

- File-based route: `/blog/post/[pid]`
- File-based route: `/[page]`
- Injected route: `/blog/[...slug]`
- Redirect: `/blog/tags/[tag] -> /[tag]`
- Redirect: `/posts -> /blog`

The following URLs will be built (instead of following the route priority order of Astro v4.x):

- `/blog/tags/astro` is built by the redirect to `/tags/[tag]` (instead of the injected route `/blog/[...slug]`)
- `/blog/post/0` is built by the file-based route `/blog/post/[pid]` (instead of the injected route `/blog/[...slug]`)
- `/posts` is built by the redirect to `/blog` (instead of the file-based route `/[page]`)

In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.

<ReadMore>Read more about the [route priority order rules](/en/guides/routing/#route-priority-order).</ReadMore>

### `<script>` tags are rendered directly as declared

<SourcePR number="11791" title="Make directRenderScript the default"/>

In Astro v4.x, `experimental.directRenderScript` was an optional flag to directly render `<scripts>` as declared in `.astro` files (including existing features like TypeScript, importing `node_modules`, and deduplicating scripts). This strategy prevented scripts from being executed in places where they were not used.

Astro 5.0 removes this experimental flag and makes this the new default behavior in Astro: scripts are no longer hoisted to the `<head>`, multiple scripts on a page are no longer bundled together, and a `<script>` tag may interfere with CSS styling.

#### Que dois-je faire ?

Please review your `<script>` tags and ensure they behave as desired.

<ReadMore>Read more about [using `script` tags in Astro](/en/guides/client-side-scripts/#using-script-in-astro).</ReadMore>

## Breaking Changes

The following changes are considered breaking changes in Astro v5.0. Breaking changes may or may not provide temporary backwards compatibility. If you were using these features, you may have to update your code as recommended in each entry.

{/* If you need to refer to the documentation for a v4.x project, you can browse this [(unmaintained) snapshot of the docs from before v5.0 was released](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/). */}

### Renamed: `<ViewTransitions />` component

<SourcePR number="11980" title="Rename the ViewTransitions component to ClientRouter"/>

In Astro 4.x, Astro's View Transitions API included a `<ViewTransitions />` router component to enable client-side routing, page transitions, and more.

Astro 5.0 renames this component to `<ClientRouter />` to clarify the role of the component within the API. This makes it more clear that the features you get from Astro's `<ClientRouter />` routing component are slightly different from the native CSS-based MPA router.

No functionality has changed. This component has only changed its name.

#### Que dois-je faire ?

Replace all occurances of the `ViewTransitions` import and component with `ClientRouter`:

```astro title="src/layouts/MyLayout.astro" del={1,7} ins={2,8}
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';

<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

<ReadMore>Read more about [view transitions and client-side routing in Astro](/en/guides/view-transitions/).</ReadMore>


### Changed: TypeScript configuration

<SourcePR number="11859" title="better tsconfig"/>

In Astro v4.x, Astro relied on a `src/env.d.ts` file for type inferencing and defining modules for features that relied on generated types.

Astro 5.0 instead uses a `.astro/types.d.ts` file for type inferencing, and now recommends setting `include` and `exclude` in `tsconfig.json` to benefit from Astro types and avoid checking built files.

Running `astro sync` no longer creates, nor updates, `src/env.d.ts` as it is not required for type-checking standard Astro projects.

#### Que dois-je faire ?

To update your project to Astro's recommended TypeScript settings, add the following `include` and `exclude` properties to your existing `tsconfig.json`:

```ts ins={3,4} title="tsconfig.json"
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

Note that `src/env.d.ts` is only necessary if you have added custom configurations, or if you're not using a `tsconfig.json` file.

<ReadMore>Read more about [TypeScript configuration in Astro](/en/guides/typescript/#setup).</ReadMore>

### Changed: Actions submitted by HTML forms no longer use cookie redirects

<SourcePR number="12373" title="Actions middleware"/>

In Astro 4.x, actions called from an HTML form would trigger a redirect with the result forwarded using cookies. This caused issues for large form errors and return values that exceeded the 4 KB limit of cookie-based storage.

Astro 5.0 now renders the result of an action as a POST result without any forwarding. This will introduce a "confirm form resubmission?" dialog when a user attempts to refresh the page, though it no longer imposes a 4 KB limit on action return value.

#### Que dois-je faire ?

You should update handling for action results that relies on redirects, and optionally address the "confirm form resubmission?" dialog with middleware.

##### To redirect to the previous route on error

If your HTML form action is directed to a different route (i.e. `action={"/success-page" + actions.name}`), Astro will no longer redirect to the previous route on error. You can implement this behavior manually using redirects from your Astro component. This example instead redirects to a new route on success, and handles errors on the current page otherwise:

```astro title="src/pages/newsletter.astro" ins={4-9} del="'/confirmation' + "
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // Embed relevant result data in the URL if needed
  // example: redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

##### (Optional) To remove the confirm dialog on refresh

To address the "confirm form resubmission?" dialog on refresh, or to preserve action results across sessions, you can now [customize action result handling from middleware](/en/guides/actions/#advanced-persist-action-results-with-a-session).

We recommend using a session storage provider [as described in our Netlify Blob example](/en/guides/actions/#advanced-persist-action-results-with-a-session). However, if you prefer the cookie forwarding behavior from 4.X and accept the 4 KB size limit, you can implement the pattern as shown in this sample snippet:

```ts title="src/middleware.ts"
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  // Skip requests for prerendered pages
  if (context.isPrerendered) return next();

	const { action, setActionResult, serializeActionResult } = getActionContext(context);

	// If an action result was forwarded as a cookie, set the result
	// to be accessible from `Astro.getActionResult()`
	const payload = context.cookies.get('ACTION_PAYLOAD');
	if (payload) {
		const { actionName, actionResult } = payload.json();
		setActionResult(actionName, actionResult);
		context.cookies.delete('ACTION_PAYLOAD');
		return next();
	}

	// If an action was called from an HTML form action,
	// call the action handler and redirect with the result as a cookie.
	if (action?.calledFrom === 'form') {
		const actionResult = await action.handler();

		context.cookies.set('ACTION_PAYLOAD', {
			actionName: action.name,
			actionResult: serializeActionResult(actionResult),
		});

		if (actionResult.error) {
		// Redirect back to the previous page on error
			const referer = context.request.headers.get('Referer');
			if (!referer) {
				throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
			}
			return context.redirect(referer);
		}
		// Redirect to the destination page on success
		return context.redirect(context.originPathname);
	}

	return next();
})
```

### Changed: `compiledContent()` is now an async function

<SourcePR number="11782" title="Remove TLA by making compiledContent async"/>

In Astro 4.x, top level await was included in Markdown modules. This caused some issues with custom image services and images inside Markdown, causing Node to suddenly exit with no error message.

Astro 5.0 makes the `compiledContent()` property on Markdown import an async function, requiring an `await` to resolve the content.

#### Que dois-je faire ?

Update your code to use `await` when calling `compiledContent()`.

```astro title="src/pages/post.astro" del={4} ins={5}
---
import * as myPost from "../blog/post.md";

const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---

<Fragment set:html={content} />
```

<ReadMore>Read more about the [`compiledContent()` function](/en/guides/markdown-content/#importing-markdown) for returning compiled Markdown.</ReadMore>

### Changed: `astro:content` can no longer be used on the client

<SourcePR number="11827" title="Prevent usage of `astro:content` in the client "/>

In Astro 4.x, it was possible to access the `astro:content` module on the client.

Astro 5.0 removes this access as it was never intentionally exposed for client use. Using `astro:content` this way had limitations and bloated client bundles.

#### Que dois-je faire ?

If you are currently currently using `astro:content` in the client, pass the data you need through props to your client components instead:

```astro title="src/pages/blog.astro"
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';

const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---

<ClientComponent posts={postsData} />
```

<ReadMore>Read more about [the `astro:content` API](/en/reference/modules/astro-content/).</ReadMore>

### Renamed: Shiki `css-variables` theme color token names

<SourcePR number="11661" title="Update to new shiki token names"/>

In Astro v4.x, the Shiki `css-variables` theme used the `--astro-code-color-text` and `--astro-code-color-background` tokens for styling the foreground and background colors of code blocks respectively.

Astro v5.0 renames them to `--astro-code-foreground` and `--astro-code-background` respectively to better align with the Shiki v1 defaults.

#### Que dois-je faire ?

You can perform a global find and replace in your project to migrate to the new token names.

```css title="src/styles/global.css" del={2,3} ins={4,5}
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: internal Shiki rehype plugin for highlighting code blocks

<SourcePR number="11825" title="Refactor createShikiHighlighter"/>

In Astro 4.x, Astro's internal Shiki rehype plugin highlighted code blocks as HTML.

Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers.

#### Que dois-je faire ?

If you are using Shiki transformers passed to `markdown.shikiConfig.transformers`, you must make sure they do not use the `postprocess` hook. This hook no longer runs on code blocks in `.md` and `.mdx` files. (See [the Shiki documentation on transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) for more information).

Code blocks in `.mdoc` files and Astro's built-in `<Code />` component do not use the internal Shiki rehype plugin and are unaffected.

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: Automatic `charset=utf-8` behavior for Markdown and MDX pages

<SourcePR number="12231" title="Unset charset=utf-8 content-type for md/mdx pages"/>

In Astro 4.0, Markdown and MDX pages (located in `src/pages/`) automatically responded with `charset=utf-8` in the `Content-Type` header, which allowed rendering non-ASCII characters in your pages.

Astro 5.0 updates the behaviour to add the `<meta charset="utf-8">` tag instead, and only for pages that do not use Astro's special `layout` frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping `Layout` component.

If your Markdown or MDX pages use the `layout` frontmatter property, or if the MDX page content imports a wrapping `Layout` component, then the HTML encoding will be handled by the designated layout component instead, and the `<meta charset="utf-8">` tag will not be added to your page by default.

#### Que dois-je faire ?

If you require `charset=utf-8` to render your page correctly, make sure that your layout components contain the `<meta charset="utf-8">` tag. You may need to add this if you have not already done so.

<ReadMore>Read more about [Markdown layouts](/en/basics/layouts/#markdown-layouts).</ReadMore>

### Changed: Astro-specific metadata attached in remark and rehype plugins

<SourcePR number="11861" title="Clean up Astro metadata in vfile.data"/>

In Astro 4.x, the Astro-specific metadata attached to `vfile.data` in remark and rehype plugins was attached in different locations with inconsistent names.

Astro 5 cleans up the API and the metadata is now renamed as below:

 - `vfile.data.__astroHeadings` -> `vfile.data.astro.headings`
 - `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths`

The types of `imagePaths` has also been updated from `Set<string>` to `string[]`. The `vfile.data.astro.frontmatter` metadata is left unchanged.

#### Que dois-je faire ?

While we don't consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro's metadata. If you are using these APIs, make sure to access them in the new locations.

<ReadMore>Read more about [using Markdown plugins in Astro](/en/guides/markdown-content/#markdown-plugins).</ReadMore>

### Changed: image endpoint configuration

<SourcePR number="11908" title="Allow customising the route of the image endpoint"/>

In Astro 4.x, you could set an endpoint in your `image` configuration to use for image optimization.

Astro 5.0 allows you to customize a `route` and `entrypoint` of the `image.endpoint` config. This can be useful in niche situations where the default route `/_image` conflicts with an existing route or your local server setup.

#### Que dois-je faire ?

If you had previously customized `image.endpoint`, move this endpoint to the new `endpoint.entrypoint` property. Optionally, you may customize a `route`:

```js title="astro.config.mjs" del={5} ins={6-9}
import { defineConfig } from "astro/config";

defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

<ReadMore>Read more about [setting an endpoint to use for image optimization](/en/reference/configuration-reference/#imageendpoint).</ReadMore>

### Changed: `build.client` and `build.server` resolve behavior

<SourcePR number="11916" title="Fix build.client and build.server resolve behaviour" />

In Astro v4.x, the `build.client` and `build.server` options were documented to resolve relatively from the `outDir` option, but it didn't always work as expected.

Astro 5.0 fixes the behavior to correctly resolve from the `outDir` option. For example, if `outDir` is set to `./dist/nested/`, then by default:

- `build.client` will resolve to `<root>/dist/nested/client/`
- `build.server` will resolve to `<root>/dist/nested/server/`

Previously the values were incorrectly resolved:

- `build.client` was resolved to `<root>/dist/nested/dist/client/`
- `build.server` was resolved to `<root>/dist/nested/dist/server/`

#### Que dois-je faire ?

If you were relying on the previous build paths, make sure that your project code is updated to the new build paths.

<ReadMore>Read more about [`build` configuration options in Astro](/en/reference/configuration-reference/#build-options).</ReadMore>

### Changed: JS dependencies in config file are no longer processed by Vite

<SourcePR number="11819" title="Set external: true when loading astro config"/>

In Astro 4.x, locally-linked JS dependencies (e.g. `npm link`, in a monorepo, etc) were able to use Vite features like `import.meta.glob` when imported by the Astro config file.

Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from `node_modules`.

This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it's also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it's an implementation detail of Astro's config loading flow.

#### Que dois-je faire ?

Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before.

<ReadMore>Read more about [Vite configuration settings in Astro](/en/reference/configuration-reference/#vite).</ReadMore>

### Changed: URLs returned by `paginate()`

<SourcePR number="11253" title="Add base to paginate"/>

In Astro v4.x, the URL returned by `paginate()` (e.g. `page.url.next`, `page.url.first`, etc.) did not include the value set for `base` in your Astro config. You had to manually prepend your configured value for `base` to the URL path.

Astro 5.0 automatically includes the `base` value in `page.url`.

#### Que dois-je faire ?

If you are using the `paginate()` function for these URLs, remove any existing `base` value as it is now added for you:

```astro del={16} ins={17}
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` configured in `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

<ReadMore>Read more about [pagination in Astro](/en/guides/routing/#pagination).</ReadMore>

### Changed: non-boolean HTML attribute values

<SourcePR number="11660" title="Fix attribute rendering for boolean values (take 2)"/>

In Astro v4.x, non-[boolean HTML attributes](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) may not have included their values when rendered to HTML.

Astro v5.0 renders the values explicitly as `="true"` or `="false"`, matching proper attribute handling in browsers.

In the following `.astro` examples, only `allowfullscreen` is a boolean attribute:

```astro
<!-- src/pages/index.astro -->
<!-- `allowfullscreen` is a boolean attribute -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` is *not* a boolean attribute -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- `data-*` attributes are not boolean attributes -->
<p data-light={true}></p>
<p data-light={false}></p>
```

Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes:

```astro del={5,8,10} ins={6,9,11}
<p allowfullscreen></p>
<p></p>

<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>

<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

#### Que dois-je faire ?

If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values:

```js del={1,4} ins={2,5}
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'

el.hasAttribute('data-light')
el.dataset.light === 'true'
```

<ReadMore>Read more about [using HTML attributes in Astro](/en/reference/astro-syntax/#dynamic-attributes).</ReadMore>

### Changed: adding values to `context.locals`

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, it was possible to completely replace the entire `locals` object in middleware, API endpoints, and pages when adding new values.

Astro 5.0 requires you to append values to the existing `locals` object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden.

#### Que dois-je faire ?

Where you previously were overwriting the object, you must now instead assign values to it:

```js title="src/middleware.js" del={1,5} ins={2,6}
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```
<ReadMore>See more about [storing data in `context.locals`](/en/guides/middleware/#storing-data-in-contextlocals).</ReadMore>

### Changed: `params` no longer decoded

<SourcePR number="12079" title="decode pathname early, don't decode params"/>

In Astro v4.x, `params` passed to `getStaticPath()` were automatically decoded using `decodeURIComponent`.

Astro v5.0 no longer decodes the value of `params` passed to `getStaticPaths`. You must manually decode them yourself if needed.

#### Que dois-je faire ?

If you were previously relying on the automatic decoding, use `decodeURI` when passing `params`.


```astro title="src/pages/[id].astro" del={4} ins={5}
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}

const { id } = Astro.params;
---
```

Note that the use of [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent)) is discouraged for `getStaticPaths` because it decodes more characters than it should, for example `/`, `?`, `#` and more.

<ReadMore>Read more about [creating dynamic routes with `params`](/en/guides/routing/#static-ssg-mode).</ReadMore>

### Changed: `RouteData` type replaced by `IntegrationsRouteData` (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, the `entryPoints` type inside the `astro:build:ssr` and `astro:build:done` hooks was `RouteData`.

Astro v5.0 the `entryPoints` type is now `IntegrationRouteData`, which contains a subset of the `RouteData` type. The fields `isIndex` and `fallbackRoutes` were removed.

#### Que dois-je faire ?

Update your adapter to change the type of `entryPoints` from `RouteData` to `IntegrationRouteData`.

```js del={1,4} ins={2,5}
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"

function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: `distURL` is now an array (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, `RouteData.distURL` was `undefined` or a `URL`

Astro v5.0 updates the shape of `IntegrationRouteData.distURL` to be `undefined` or an array of `URL`s. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as `[slug]` or `[...slug]`.

#### Que dois-je faire ?

Update your code to handle `IntegrationRouteData.distURL` as an array.

```js del={2-4} ins={5-9}
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // do something
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // do something
    }
  }
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: Arguments passed to `app.render()` (Adapter API)

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, The Adapter API method `app.render()` could receive three arguments: a mandatory `request`, an object of options or a `routeData` object, and `locals`.

Astro 5.0 combines these last two arguments into a single options argument named `renderOptions`.

#### Que dois-je faire ?

Pass an object as the second argument to `app.render()`, which can include `routeData` and `locals` as properties.

```js del={1} ins={2}
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

<ReadMore>See the [Adapter API reference for `renderOptions`](/en/reference/adapter-reference/#renderoptions).</ReadMore>

### Changed: Properties on `supportedAstroFeatures` (Adapter API)

<SourcePR number="11806" title="rework supportedAstroFeatures"/>

In Astro 4.x, `supportedAstroFeatures`, which allows adapter authors to specify which features their integration supports, included an `assets` property to specify which of Astro's image services were supported.

Astro 5.0 replaces this property with a dedicated `sharpImageService` property, used to determine whether the adapter is compatible with the built-in sharp image service.

v5.0 also adds a new `limited` value for the different properties of `supportedAstroFeatures` for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options.

Additionally, the value of the different properties on `supportedAstroFeatures` for adapters can now be objects, with `support` and `message` properties. The content of the `message` property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new `limited` value, to explain to the user why support is limited.

#### Que dois-je faire ?

If you were using the `assets` property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with `sharpImageService`.

You may also wish to update your supported features with the new `limited` option and include a message about your adapter's support.

```ts title="my-adapter.mjs" del={2-6} ins={7-10}
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'This adapter supports the built-in sharp image service, but with some limitations.'
  }
}
```

<ReadMore>Read more about [specifying supported Astro features in an adapter](/en/reference/adapter-reference/#astro-features).</ReadMore>

### Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)

<SourcePR number="11987" title="Remove deprecated dev toolbar app shape"/>

In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated `addDevToolbarApp(string);` signature. The `id`, `title`, and `icon` properties to define the app were then made available through the default export of the app's `entrypoint`.

Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that's more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly.

#### Que dois-je faire ?

If you were using the deprecated shape, update your dev toolbar app to use the new shape:

```js title="my-integration.mjs" del={1-2} ins={4-10}
// Old shape
addDevToolbarApp("./my-app.js");

// New shape
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-app.js",
});
```

```js title="my-dev-toolbar-app.mjs" del={2-4}
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

<ReadMore>Read more about [developing a dev toolbar app for Astro using the Dev Toolbar API](/en/reference/dev-toolbar-app-reference/).</ReadMore>

### Removed: configuring Typescript during `create-astro`

<SourcePR number="12083" title="create-astro updates"/>

In Astro v4.x, it was possible to choose between Astro's three TypeScript settings when creating a new project using `create astro`, either by answering a question or by passing an associated `--typescript` flag with the desired TypeScript setting. 

Astro 5.0 updates the `create astro` CLI command to remove the TypeScript question and its associated `--typescript` flag. The "strict" preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in `tsconfig.json`.

#### Que dois-je faire ?

If you were using the `--typescript` flag with `create-astro`, remove it from your command.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```diff lang=shell
  -npm create astro@latest -- --template <example-name> --typescript strict
  +npm create astro@latest -- --template <example-name>
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```diff lang=shell
  -pnpm create astro@latest --template <example-name> --typescript strict
  +pnpm create astro@latest --template <example-name>
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```diff lang=shell
  -yarn create astro --template <example-name> --typescript strict
  +yarn create astro --template <example-name>
  ```
  </Fragment>
</PackageManagerTabs>

<ReadMore>See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)</ReadMore>

## Community Resources

Know a good resource for Astro v5.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v5.mdx) and add a link below!

## Known Issues

Please check [Astro's issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.
